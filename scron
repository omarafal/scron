#!/bin/bash

# start logging
#log_file="$s_path/logs/scron.log"
#date_format="$(date +'[%a %I:%M:%S]')" 
#echo $date_format >> $log_file 2>>&1

s_path=$(dirname $(realpath $0))

# check if command directory exists
if [ ! -d $s_path/commands ]
then
	mkdir $s_path/commands
fi

# help menu
print_help() {
	echo "Correct usage:"
	echo -e "scron [OPTION]\n"
	echo "Options:"
	echo -e "  -h\tdisplay help menu"
	echo -e "  -f\tspecify commands file"
	echo -e "  -p\tpurge; empty ALL scheduled commands"
	echo -e "  -l\tlist scheduled commands"
	echo -e "  -t\tset time for scheduled commands"
	echo -e "  -c\tschedule a single command"
	echo -e "  -r\trestore the scron file to the last state it was in"
}

purge() {

	crontab -l > /dev/null 2>&1

	# if no crontab file found
	if [ ! $? -eq 0 ]
	then
		scron -l > /dev/null

		if [ $? -eq 0 ]
		then

			echo "No scheduled commands in crontab found for this user, clearing scron files anyway."
		fi
	fi

	verbose_clear=$s_path/commands/verbose_cmds.scron
	short_clear=$s_path/commands/short_cmds.scron
	
	# prompt for confirmation and create backup
	read -p "Are you sure you want to remove ALL the currently scheduled commands?(Y/n): " do_clear
	
	if [[ $do_clear != 'Y' ]]
	then
		echo "Aborting."
		exit 101
	fi
	
	crontab -r > /dev/null 2>&1

	if [ ! -d $s_path/backups ]
	then
		mkdir $s_path/backups
	fi
	

	# make a backup directory to store old files
	backup_dir="$s_path/backups/$(date +'[%N]%F')"
	
	if [ ! -d $backup_dir ]
	then
		mkdir $backup_dir
	fi

	cp $verbose_clear $backup_dir/
	cp $short_clear $backup_dir/

	truncate -s 0 $verbose_clear && truncate -s 0 $short_clear
	 

	echo "Created a backup for the last state."
	echo "Successfully cleared the crontab file."

	exit 0
}

# handle commands file
set_cmds(){
	#cat $1
	#file_content=$(cat $1)

	if [ -f $1 ]
	then
		#echo "File exists."
		#cat $1 | python3 $s_path/parse_content.py
		# send file name and time to python
		python3 $s_path/parse_content.py $1 "$2" $3
		#echo "EXIT CODE FROM PYTHON: $?"

		if [ $? -eq 0 ]
		then
			crontab -T $s_path/commands/verbose_cmds.tmp > /dev/null 2>&1
			# check if crontab is successful then copy to original files from temp
			if [ $? -eq 0 ]
			then
				cat $s_path/commands/verbose_cmds.tmp >> $s_path/commands/verbose_cmds.scron
				cat $s_path/commands/short_cmds.tmp >> $s_path/commands/short_cmds.scron
				
				# make crontab read the file
				crontab $s_path/commands/verbose_cmds.scron > /dev/null 2>&1

				# check for logs directory
				if [ ! -d $s_path/logs ]
				then
					mkdir $s_path/logs
				fi

				echo "Successfully scheduled provided commands."
				echo "You can view all the scheduled commands by scron -l"
				exit 0
			else
				echo "[ERROR] Something went wrong, please check your commands' syntax." >&2
				exit 201
			fi
			
		fi
	else
		echo "[ERROR] No such file found." >&2
		exit 203
	fi

}

# list all scheduled commands
list() {
	# check if file is empty
	if [ ! -s $s_path/commands/short_cmds.scron ]
	then
		echo "[ERROR] No scheduled commands found in scron." >&2
		exit 204
	fi

	
	cat $s_path/commands/short_cmds.scron
	exit 0
}

# restore scron file to the last state in case it was tampered with
restore() {

	# I just realised I can use the temp file to restore the state (it's 4 am here forgive me)
	# Also this feature is kinda useless and its main functionality is not to just restore the last state
	# since I can also tamper with the temp file, but maybe later.

	if [ ! -s $s_path/commands/verbose_cmds.tmp ]
	then
		echo "[ERROR] No backup found, you have to first schedule commands."
		exit 204
	fi

	cat $s_path/commands/verbose_cmds.tmp > $s_path/commands/verbose_cmds.scron
	
	echo "Successfully restored the scron file to its last state."
	exit 0
}

# variables
time=null
file=null

# options
while getopts ":hf:plt:r" opt
do
	case $opt in
		h) print_help && exit 0;;
		f) file=$OPTARG;;
		p) purge;;
		l) list;; 
		t) time=$OPTARG;;
		r) restore ;;
		:) echo "[ERROR] scron -$OPTARG requires argument(s)" >&2; exit 4 ;;
		\?) echo -e "[ERROR] Invalid option\n" >&2 && print_help ; exit 1;;
		*) echo "Error" && exit 255
	esac
done

# check variables are set
if [[ $file == null || $time == null ]]
then
	echo "[ERROR] Missing file or time arguments." >&2
	echo "Example usage: scron -t \"23 Jan @ 8:30 AM\" -f file.txt "
	exit 2
fi

set_cmds $file "$time" $s_path
