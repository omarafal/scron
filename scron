#!/bin/bash

# start logging
#log_file="$s_path/logs/scron.log"
#date_format="$(date +'[%a %I:%M:%S]')" 
#echo $date_format >> $log_file 2>>&1

s_path=$(dirname $(realpath $0))

# help menu
print_help() {
	echo "Correct usage:"
	echo -e "scron [OPTION]\n"
	echo "Options:"
	echo -e "  -h\tdisplay help menu"
	echo -e "  -f\tspecify commands file"
	echo -e "  -p\tpurge; empty ALL scheduled commands"
	echo -e "  -l\tlist scheduled commands"
	echo -e "  -t\tset time for scheduled commands"
	echo -e "  -c\tschedule a single command"
	echo -e "  -r\trestore the crontab file to the last state it was in"
	echo -e "  -e\tevery; run command(s) every provided time"
	exit
	#echo "\n"
	#echo "Example time formats:"
	#echo "23 Jan @ 8:30 PM -> runs every 23rd of January on 8:30 pm."
	#echo "23 @ 8:30 PM -> runs every 23rd of every month on 8:30 pm."  
	#echo "Sat Jan @ 8:30 PM -> runs every Saturday of every month on 8:30 pm."
	#echo "Sat @ 8:30 PM -> runs every Saturday of every month on 8:30 pm."
      	#please refer to the man page or documentation
	# scron is not responsible for command syntax or date correctness (eg: 31 Sep which doesn't exist)
	# echo "Sat @ every-day also every-boot, every-minute, every-hour"
	# echo "Jun @ time" means every day for the month of Jun	
}

purge() {

	crontab -r
	
	# if no crontab file found
	if [ ! $? -eq 0 ]
	then
		exit
	fi

	verbose_clear=$s_path/commands/verbose_cmds.scron
	short_clear=$s_path/commands/short_cmds.scron
	
	# prompt for confirmation and create backup
	read -p "Are you sure you want to remove ALL the currently sgicheduled commands?(Y/n): " do_clear
	
	if [[ $do_clear != 'Y' ]]
	then
		echo "Aborting."
		exit
	fi
	
	if [ ! -d backups ]
	then
		mkdir $s_path/backups
	fi

	cp $verbose_clear $s_path/backups/$(date +%F).scron.bkup

	truncate -s 0 $verbose_clear && truncate -s 0 $short_clear
	 

	echo "Created a backup for the last state."
	echo "Successfully cleared the crontab file."
}

# handle commands file
set_cmds(){
	#cat $1
	#file_content=$(cat $1)

	if [ -f $1 ]
	then
		#echo "File exists."
		#cat $1 | python3 $s_path/parse_content.py
		# send file name and time to python
		python3 $s_path/parse_content.py $1 "$2" $3
		#echo "EXIT CODE FROM PYTHON: $?"

		if [ $? -eq 0 ]
		then
			crontab -T $s_path/commands/verbose_cmds.tmp >> /dev/null
			# check if crontab is successful then copy to original files from temp
			if [ $? -eq 0 ]
			then
				cat $s_path/commands/verbose_cmds.tmp >> $s_path/commands/verbose_cmds.scron
				cat $s_path/commands/short_cmds.tmp >> $s_path/commands/short_cmds.scron
				# now make crontab read the file
				crontab $s_path/commands/verbose_cmds.scron
			else
				echo "[ERROR] Something went wrong, please check your commands' syntax."
			fi
			
		fi
	else
		echo "[ERROR] No such file found."
		exit
	fi

}

# variables
time=null
file=null


# options
while getopts ":hf:plt:" opt
do
	case $opt in
		h) print_help;;
		f) file=$OPTARG;;
		p) purge; exit;;
		l) cat $s_path/commands/short_cmds.scron; exit;;
		t) time=$OPTARG;;
		:) echo "[ERROR] scron -$OPTARG requires argument(s)"; exit;;
		\?) echo -e "[ERROR] Invalid option\n" && print_help ; exit;;
		*) echo "Error" && exit
	esac
done

# check variables are set
if [[ $file == null || $time == null ]]
then
	echo "[ERROR] Missing file or time arguments."
	echo "Example usage: scron -t \"23 Jan @ 8:30 AM\" -f file.txt "
	exit
fi

set_cmds $file "$time" $s_path
